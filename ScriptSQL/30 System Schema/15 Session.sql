--
-- **************************
-- ** APPLICATION DATABASE **
-- **************************
--

-- Paolo De Stefani 01.2025

-- This script MUST be executed by postgres user or a postgres like user
-- Connected to a database ("postgres" database is OK)

---------------------------------
-- APPLICATION DB ARCHITECTURE --
---------------------------------

-- * one database {pyAppPgDataBase}
-- * one role that own the database {pyAppPgOwnerRole} without login privilege
-- * one login role {pyAppPgLoginRole} that inherit {pyAppPgOwnerRole} privileges

-- Every database has 4 schemas:
-- * system     for system objects
-- * common     for common objects that are shared with all companies
-- * company    for objects associated with a company
-- * temp       for temporary tables

-- This set of variables will be be resolved before executing the scripts:
-- {pyAppPgOwnerRole}           = PostgresSQL Role that own all db objects without login privilege
-- {pyAppPgDataBase}            = Postgres database name
-- {pyAppPgLoginRole}           = PostgresSQL Role used for standard login users
-- {pyAppPgLoginPassword}       = Password for pyAppPgLoginRole
-- {pyAppName}                  = Python application name
-- {pyAppDescription}           = Python application description
-- {pyAppVersionMajor}          = Application version major number
-- {pyAppVersionMinor}          = Application version minor number
-- {pyAppVersionPatch}          = Application version patch number
-- {pyAppVersionTag}            = Application version tag
-- {pyAppVersionDescription}    = Application version description
-- {pyAppPgDataBaseTS}          = Database table space (MUST be created before script execution)
-- {pyAppPgTablesTS}            = Tables table space (MUST be created before script execution)
-- {pyAppPgIndexesTS}           = Indexes table space (MUST be created before script execution)


---------------------------
-- SYSTEM SCHEMA OBJECTS --
---------------------------

SET search_path = system;


-- system table: curent connections
CREATE TABLE connection (
    session_id              integer DEFAULT pg_backend_pid(),
    access_date             timestamptz(3) NOT NULL DEFAULT now(),
    db_user_name            varchar(48) NOT NULL DEFAULT current_user,
    app_user_code           varchar(48) NOT NULL, -- don't set a foreign key on "user_id" for cross dependencies (system.pa_current_user())
    client_name             varchar(48) NOT NULL,
    client_ip               inet NOT NULL DEFAULT inet_client_addr(),
    client_port             integer NOT NULL DEFAULT inet_client_port(),
    company_id              integer, 
        -- don't set a foreign key on "company" for cross dependencies (system.pa_current_user())
        -- don't use NOT NULL, first time user have no company setted
    profile_code            varchar(48),
        -- don't set a foreign key on "profile" for cross dependencies (system.pa_current_user())
        -- don't use NOT NULL, first time user have no profile setted
    --
    CONSTRAINT connection_pk 
        PRIMARY KEY (session_id) 
        USING INDEX TABLESPACE {pyAppPgIndexesTS} 
    )
TABLESPACE {pyAppPgTablesTS};
COMMENT ON TABLE connection IS
    'Current application connections';
ALTER TABLE connection 
    OWNER TO {pyAppPgOwnerRole};


-- system table: connections history
CREATE TABLE connection_history (
    history_id              BIGINT GENERATED BY DEFAULT AS IDENTITY,
    session_id              integer NOT NULL,
    login_datetime          timestamptz(3) NOT NULL,
    logout_datetime         timestamptz(3) NULL,
    db_user_name            varchar(48) NOT NULL,
    app_user_code           varchar(48) NOT NULL,
    client_name             varchar(48) NOT NULL,
    client_ip               inet NOT NULL,
    client_port             integer NOT NULL,
    company_desc            text,
    profile_code            varchar(48), -- don't use NOT NULL, first time user have no profile setted
    --
    CONSTRAINT connection_history_pk 
        PRIMARY KEY (history_id) 
        USING INDEX TABLESPACE {pyAppPgIndexesTS}
    )
TABLESPACE {pyAppPgTablesTS};
COMMENT ON TABLE connection_history IS
    'Connections history updated on connection exit';
ALTER TABLE connection_history 
    OWNER TO {pyAppPgOwnerRole};


-- trigger function: fill connections logs from current connections
CREATE FUNCTION update_connection_history() 
RETURNS trigger AS
$$
DECLARE
    rec system.connection_history;
BEGIN
    rec.session_id := OLD.session_id;
    rec.login_datetime := OLD.access_date;
    rec.logout_datetime := now();
    rec.db_user_name := OLD.db_user_name;
    rec.app_user_code := OLD.app_user_code;
    rec.client_name := OLD.client_name;
    rec.client_ip := OLD.client_ip;
    rec.client_port := OLD.client_port;
    rec.company_desc := (SELECT OLD.company_id::text || ' ' || left(description, 30) 
                         FROM system.company 
                         WHERE company_id = OLD.company_id);
    rec.profile_code := OLD.profile_code;
    
    INSERT INTO system.connection_history (
        session_id,
        login_datetime,
        logout_datetime,
        db_user_name,
        app_user_code,
        client_name,
        client_ip,
        client_port,
        company_desc,
        profile_code
        )
    VALUES (
        rec.session_id,
        rec.login_datetime,
        rec.logout_datetime,
        rec.db_user_name,
        rec.app_user_code,
        rec.client_name,
        rec.client_ip,
        rec.client_port,
        rec.company_desc,
        rec.profile_code
        );
    -- delelete older records
    IF system.pa_setting('clear_connection_history') IS NOT NULL THEN
        DELETE FROM system.connection_history
        WHERE logout_datetime < current_date - system.pa_setting('clear_connection_history')::int;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;
COMMENT ON FUNCTION update_connection_history() IS
    'Trigger function that fill commections history table from current connections';
ALTER FUNCTION update_connection_history() 
    OWNER TO {pyAppPgOwnerRole};

CREATE TRIGGER t10_connection_history_autoupdate 
    AFTER DELETE ON connection
    FOR EACH ROW EXECUTE PROCEDURE update_connection_history();


-- system function: get current connected user or system user
CREATE FUNCTION pa_current_user()
RETURNS text AS
$$
DECLARE
    cur_user varchar;
BEGIN
    SELECT app_user_code INTO cur_user 
    FROM system.connection 
    WHERE session_id = pg_backend_pid();
    IF cur_user IS NULL THEN
        -- if not connected current user is assumed to be the system administrator, used on installation/upgrade database
        cur_user = system.pa_setting('app_system_user'); 
    END IF;
    RETURN cur_user;
END;
$$
LANGUAGE plpgsql;
COMMENT ON FUNCTION pa_current_user() IS 
    'Get current user function';
ALTER FUNCTION pa_current_user() 
    OWNER TO {pyAppPgOwnerRole};


-- system function: get current company
CREATE FUNCTION pa_current_company()
RETURNS int AS
$$
BEGIN
    RETURN (
        SELECT company_id 
        FROM system.connection 
        WHERE session_id = pg_backend_pid()
        );
END;
$$
LANGUAGE plpgsql;
COMMENT ON FUNCTION pa_current_company() IS 
    'Get current company function';
ALTER FUNCTION pa_current_company() 
    OWNER TO {pyAppPgOwnerRole};


-- system function: get current profile
CREATE FUNCTION pa_current_profile()
RETURNS varchar(40) AS
$$
BEGIN
    RETURN (
        SELECT profile_code 
        FROM system.connection 
        WHERE session_id = pg_backend_pid()
        );
END;
$$
LANGUAGE plpgsql;
COMMENT ON FUNCTION pa_current_profile() IS 
    'Get current profile function';
ALTER FUNCTION pa_current_profile() 
    OWNER TO {pyAppPgOwnerRole};


-- trigger function: update company/user/date on record insert/update and object version
CREATE FUNCTION update_company_user_date()
RETURNS trigger AS
$$
BEGIN
    CASE TG_OP
        WHEN 'INSERT' THEN
            NEW.created_at := now();
            NEW.created_by := system.pa_current_user();
            NEW.updated_at := NEW.created_at;
            NEW.updated_by := NEW.created_by;
            NEW.object_version = 0;
            IF EXISTS(
                SELECT column_name 
                FROM information_schema.columns 
                WHERE table_schema = TG_TABLE_SCHEMA 
                    AND table_name = TG_TABLE_NAME 
                    AND column_name = 'company_id'
                ) THEN
                IF NEW.company_id IS Null THEN
                    NEW.company_id = system.pa_current_company();
                END IF;
            END IF;
        WHEN 'UPDATE' THEN
            NEW.updated_by := system.pa_current_user();
            NEW.updated_at := now();
            IF OLD.object_version = 2147483647 THEN -- avoid overflow
            	NEW.object_version = 1;
            ELSE
            	NEW.object_version = OLD.object_version + 1;
            END IF;
            -- On update don't neew to set company_id
    END CASE;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
COMMENT ON FUNCTION update_company_user_date() IS 
    'Trigger function that fills user/company in insert/upgrade data ad updates object_version';
ALTER FUNCTION update_company_user_date() 
    OWNER TO {pyAppPgOwnerRole};
