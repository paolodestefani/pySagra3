--
-- **************************
-- ** APPLICATION DATABASE **
-- **************************
--

-- Paolo De Stefani 01.2025

-- This script MUST be executed by postgres user or a postgres like user
-- Connected to a database ("postgres" database is OK)

---------------------------------
-- APPLICATION DB ARCHITECTURE --
---------------------------------

-- * one database {pyAppPgDataBase}
-- * one role that own the database {pyAppPgOwnerRole} without login privilege
-- * one login role {pyAppPgLoginRole} that inherit {pyAppPgOwnerRole} privileges

-- Every database has 4 schemas:
-- * system     for system objects
-- * common     for common objects that are shared with all companies
-- * company    for objects associated with a company
-- * temp       for temporary tables

-- This set of variables will be be resolved before executing the scripts:
-- {pyAppPgOwnerRole}           = PostgresSQL Role that own all db objects without login privilege
-- {pyAppPgDataBase}            = Postgres database name
-- {pyAppPgLoginRole}           = PostgresSQL Role used for standard login users
-- {pyAppPgLoginPassword}       = Password for pyAppPgLoginRole
-- {pyAppName}                  = Python application name
-- {pyAppDescription}           = Python application description
-- {pyAppVersionMajor}          = Application version major number
-- {pyAppVersionMinor}          = Application version minor number
-- {pyAppVersionPatch}          = Application version patch number
-- {pyAppVersionTag}            = Application version tag
-- {pyAppVersionDescription}    = Application version description
-- {pyAppPgDataBaseTS}          = Database table space (MUST be created before script execution)
-- {pyAppPgTablesTS}            = Tables table space (MUST be created before script execution)
-- {pyAppPgIndexesTS}           = Indexes table space (MUST be created before script execution)


----------------------------
-- COMPANY SCHEMA OBJECTS --
----------------------------

SET search_path = company;


-- document numbers
DROP TABLE IF EXISTS numbering CASCADE;
CREATE TABLE numbering (
    created_at          timestamptz(3) NOT NULL,
	created_by          text NOT NULL,
    updated_at          timestamptz(3) NOT NULL,
	updated_by          text NOT NULL,
    object_version      integer NOT NULL,
    --
    company_id          integer NOT NULL,
    --
    numbering_id        integer GENERATED BY DEFAULT AS IDENTITY,
    sequence_type       varchar(48) NOT NULL,
    event_id            integer NOT NULL,
    event_date          date NULL,
    day_part            CHAR NULL,
    current_value       integer NOT NULL DEFAULT 0,
    --
    CONSTRAINT numbering_pk 
        PRIMARY KEY (numbering_id ) 
        USING INDEX TABLESPACE {pyAppPgIndexesTS},
    CONSTRAINT numbering_company_fk 
        FOREIGN KEY (company_id)
        REFERENCES system.company (company_id) 
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
    CONSTRAINT numbering_sequence_type_check 
        CHECK (sequence_type IN ('ORDERNUM'), -- order number and order count 
    CONSTRAINT numbering_event_fk 
        FOREIGN KEY (event_id) 
        REFERENCES event (event_id)
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
    CONSTRAINT numbering_day_part_check 
        CHECK (day_part IN ('L', 'D')) -- (L)unch / (D)inner

) TABLESPACE {pyAppPgTablesTS};
COMMENT ON TABLE numbering IS 
    'This table stores current numbering for order';
ALTER TABLE numbering 
    OWNER TO {pyAppPgOwnerRole};

CREATE TRIGGER t99_update_company_user_date 
    BEFORE INSERT OR UPDATE ON numbering  
    FOR EACH ROW EXECUTE PROCEDURE system.update_company_user_date();


-- updating numbering trigger
CREATE FUNCTION update_numbering_table() 
RETURNS trigger AS
$$  
DECLARE 
    num integer;
    lunch_time time;
    dinner_time time;   
BEGIN
    -- update current order number if > of the previous, create a record if not present
    num :=  (
        SELECT current_value
        FROM company.numbering
        WHERE sequence_type = 'ORDERNUM'
            AND event_id = NEW.event_id);
    IF num IS NULL THEN
        INSERT INTO company.numbering (sequence_type, company_id, event_id, current_value) 
        VALUES ('ORDERNUM', NEW.company_id, NEW.event_id, 0);
        num := 0;
    END IF;
    IF NEW.order_number > num THEN
        UPDATE company.numbering 
        SET current_value = NEW.order_number 
        WHERE sequence_type = 'ORDERNUM' 
            AND event_id = NEW.event_id; -- event include company
    END IF;
    RETURN NULL;
END
$$ 
LANGUAGE plpgsql;
COMMENT ON FUNCTION update_numbering_table() IS
    'Function for update numbering';
ALTER FUNCTION update_numbering_table() 
    OWNER TO {pyAppPgOwnerRole};



-- trigger for update order header status on order header department update
CREATE FUNCTION order_header_status_update() 
RETURNS trigger AS 
$$
BEGIN
    -- order header status will be (P)rocessing if some header department is not processed otherwise (C)ompleted
	IF (
        SELECT bool_and(CASE WHEN fullfillment_date IS NULL THEN false ELSE true END) 
        FROM company.order_header_department 
        WHERE order_header_id = NEW.order_header_id
        ) THEN
        UPDATE company.order_header 
        SET status = 'P', fullfillment_date = now() 
        WHERE order_header_id = NEW.order_header_id;
	ELSIF ( 
        SELECT bool_or(CASE WHEN fullfillment_date IS NULL THEN false ELSE true END) 
        FROM company.order_header_department 
        WHERE order_header_id = NEW.order_header_id
        ) THEN
		UPDATE company.order_header 
        SET status = 'I', fullfillment_date = Null 
        WHERE order_header_id = NEW.order_header_id;
    ELSE
        UPDATE company.order_header
        SET status = 'A', fullfillment_date = Null 
        WHERE order_header_id = NEW.order_header_id;
	END IF;
    RETURN NULL;
END;
$$ 
LANGUAGE plpgsql;
COMMENT ON FUNCTION order_header_status_update() IS
    'Function for order header status update';
ALTER FUNCTION order_header_status_update() 
    OWNER TO {pyAppPgOwnerRole};


-- order header table
CREATE TABLE order_header (
    created_at              timestamptz(3) NOT NULL,
	created_by              text NOT NULL,
    updated_at              timestamptz(3) NOT NULL,
	updated_by              text NOT NULL,
    object_version          integer NOT NULL,
    --
    company_id              integer NOT NULL,
    --
    order_header_id         integer GENERATED BY DEFAULT AS IDENTITY,
    event_id                integer NOT NULL,
    date_time               timestamptz(3) NOT NULL DEFAULT now(),
    order_number            integer NOT NULL,
    order_date              date NOT NULL,
    order_time              time NOT NULL,
    stat_order_date         date NOT NULL,
    stat_order_day_part     CHAR NOT NULL,
	cash_desk               text NOT NULL,
    delivery                char NOT NULL,
    table_num               varchar(10),
    customer_name           varchar(60),
    covers                  integer,
    total_amount            numeric(12, 2) NOT NULL DEFAULT 0,
    discount                numeric(12, 2) NOT NULL DEFAULT 0,
    cash                    numeric(12, 2) NOT NULL DEFAULT 0,
    change                  numeric(12, 2) NOT NULL DEFAULT 0,
    is_electronic_payment   boolean NOT NULL DEFAULT false,
	status                  char NOT NULL DEFAULT 'A',
    is_from_web             boolean NOT NULL DEFAULT false,
    customer_contact        varchar(128), -- email or other contact info
	fullfillment_date       timestamptz(3) NULL,
    external_code           integer,
    --
    CONSTRAINT order_header_pk 
        PRIMARY KEY (order_header_id) 
        USING INDEX TABLESPACE {pyAppPgIndexesTS},
    CONSTRAINT order_header_company_fk 
        FOREIGN KEY (company_id)
        REFERENCES system.company (company_id) 
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
    CONSTRAINT order_header_delivery_check 
        CHECK (delivery IN ('T', 'A')), -- (T)able or take(A)way
    CONSTRAINT order_header_day_part_check 
        CHECK (stat_order_day_part IN ('L', 'D')), -- (L)unch / (D)inner
	CONSTRAINT order_header_status_check 
        CHECK (status IN ('A', 'I', 'P')), -- (A)quired, (I)in progress, (P)rocessed
    CONSTRAINT order_header_event_fk 
        FOREIGN KEY (event_id) 
        REFERENCES event (event_id)
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
    CONSTRAINT order_header_docnum_unique 
        UNIQUE (event_id, order_number, order_date)

) TABLESPACE {pyAppPgTablesTS};
COMMENT ON TABLE order_header IS 
    'Order headers table';
ALTER TABLE order_header 
    OWNER TO {pyAppPgOwnerRole};

CREATE INDEX order_header_index 
    ON company.order_header (company_id, order_header_id, event_id, order_date);

CREATE TRIGGER t10_update_numbering 
    AFTER INSERT OR UPDATE ON order_header 
    FOR EACH ROW EXECUTE PROCEDURE update_numbering_table();

CREATE TRIGGER t99_update_company_user_date 
    BEFORE INSERT OR UPDATE ON order_header 
    FOR EACH ROW EXECUTE PROCEDURE system.update_company_user_date();


-- order header department table
CREATE TABLE order_header_department (
    created_at                  timestamptz(3) NOT NULL,
	created_by                  text NOT NULL,
    updated_at                  timestamptz(3) NOT NULL,
	updated_by                  text NOT NULL,
    object_version              integer NOT NULL,
    --
    company_id                  integer NOT NULL,
    --
    order_header_department_id  integer GENERATED BY DEFAULT AS IDENTITY,
    order_header_id             integer NOT NULL,
    department_id               integer NOT NULL,
    note                        text,
    other_departments           text,
	fullfillment_date           timestamptz(3) NULL,
    external_code               integer,
    --
    CONSTRAINT order_header_department_pk 
        PRIMARY KEY (order_header_department_id) 
        USING INDEX TABLESPACE {pyAppPgIndexesTS},
    CONSTRAINT order_header_department_company_fk 
        FOREIGN KEY (company_id)
        REFERENCES system.company (company_id) 
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
    CONSTRAINT order_header_department_header_fk 
        FOREIGN KEY (order_header_id) 
        REFERENCES order_header (order_header_id)
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
    CONSTRAINT order_header_department_department_fk 
        FOREIGN KEY (department_id) 
        REFERENCES department (department_id)
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION

) TABLESPACE {pyAppPgTablesTS};
COMMENT ON TABLE order_header_department IS 
    'Order headers department table';
ALTER TABLE order_header_department 
    OWNER TO {pyAppPgOwnerRole};

CREATE INDEX order_header_department_index 
    ON company.order_header_department (company_id, order_header_department_id, order_header_id, department_id);

CREATE TRIGGER t10_update_order_header_status 
    AFTER UPDATE ON order_header_department 
    FOR EACH ROW EXECUTE PROCEDURE order_header_status_update();

CREATE TRIGGER t99_update_company_user_date 
    BEFORE INSERT OR UPDATE ON order_header_department 
    FOR EACH ROW EXECUTE PROCEDURE system.update_company_user_date();


-- order line table (for customer)
CREATE TABLE order_line (
    created_at              timestamptz(3) NOT NULL,
	created_by              text NOT NULL,
    updated_at              timestamptz(3) NOT NULL,
	updated_by              text NOT NULL,
    object_version          integer NOT NULL,
    --
    company_id              integer NOT NULL,
    --
    order_line_id           integer GENERATED BY DEFAULT AS IDENTITY,
    order_header_id         integer NOT NULL,
    item_id                 integer NOT NULL,
    variants                text,
    quantity                numeric(12, 2) NOT NULL DEFAULT 1,
    price                   numeric(12, 2) NOT NULL DEFAULT 0,
    amount                  numeric(12, 2) NOT NULL DEFAULT 0,
    external_code           integer,
    --
    CONSTRAINT order_line_pk 
        PRIMARY KEY (order_line_id) 
        USING INDEX TABLESPACE {pyAppPgIndexesTS},
    CONSTRAINT order_line_header_fk 
        FOREIGN KEY (order_header_id) 
        REFERENCES order_header (order_header_id)
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
    CONSTRAINT order_line_company_fk 
        FOREIGN KEY (company_id)
        REFERENCES system.company (company_id) 
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
    CONSTRAINT order_line_item_fk 
        FOREIGN KEY (item_id) 
        REFERENCES item (item_id)
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION

) TABLESPACE {pyAppPgTablesTS};
COMMENT ON TABLE order_line IS 
    'Order line table';
ALTER TABLE order_line 
    OWNER TO {pyAppPgOwnerRole};

CREATE INDEX order_line_index 
    ON company.order_line (company_id, order_line_id, order_header_id);

CREATE TRIGGER t99_update_company_user_date 
    BEFORE INSERT OR UPDATE ON order_line 
    FOR EACH ROW EXECUTE PROCEDURE system.update_company_user_date();


-- trigger for update unloads (inventory and unloads)
CREATE FUNCTION order_line_to_unloaded() 
    RETURNS trigger AS 
$$
DECLARE
    ity         char; -- item tpe
    ipr         int; -- item part
    qty         numeric(12, 2); -- part quantity
BEGIN
    --
    CASE TG_OP
    --
    WHEN  'INSERT' THEN
        -- get item type
        SELECT item_type INTO ity 
        FROM company.item 
        WHERE item_id = NEW.item_id; -- item include company
        -- for kit item
        IF ity = 'K' THEN
            FOR ipr, qty IN SELECT part_id, quantity 
                            FROM company.item_part 
                            WHERE item_id = NEW.item_id 
                LOOP
                    -- for stock inventory
                    UPDATE company.stock_inventory 
                    SET unloaded = unloaded + NEW.quantity * qty
                    WHERE event_id = NEW.event_id 
                        AND item_id = ipr; -- only record alredy present are updated
                    -- for stock unload
                    -- initialize values on not present/change day/change daypart
                    IF NOT EXISTS(  SELECT stock_unload_id 
                                    FROM company.stock_unload 
                                    WHERE event_id = NEW.event_id 
                                        AND event_date = NEW.event_date 
                                        AND day_part = NEW.day_part 
                                        AND item_id = ipr) THEN
                        INSERT INTO company.stock_unload (company_id, event_id, event_date, day_part, item_id) 
                        VALUES (NEW.company_id, NEW.event_id, NEW.event_date, NEW.day_part, ipr);
                    END IF;
                    -- update unloaded
                    UPDATE company.stock_unload
                    SET unloaded = unloaded + NEW.quantity * qty
                    WHERE event_id = NEW.event_id 
                        AND event_date = NEW.event_date 
                        AND day_part = NEW.day_part 
                        AND item_id = ipr;
                END LOOP;
        -- normal items, menu are not present in order_line_department
        ELSE
            -- for stock inventory
            UPDATE company.stock_inventory 
            SET unloaded = unloaded + NEW.quantity
            WHERE event_id = NEW.event_id 
                AND item_id = NEW.item_id; -- only record alredy present are updated
            -- for stock unload
            -- initialize values on not present/change day/change daypart
            IF NOT EXISTS(  SELECT stock_unload_id 
                            FROM company.stock_unload 
                            WHERE event_id = NEW.event_id 
                                AND event_date = NEW.event_date  
                                AND day_part = NEW.day_part 
                                AND item_id = NEW.item_id) THEN
                INSERT INTO company.stock_unload (company_id, event_id, event_date, day_part, item_id) 
                VALUES (NEW.company_id, NEW.event_id, NEW.event_date, NEW.day_part, NEW.item_id);
            END IF;
            -- update unload
            UPDATE company.stock_unload
            SET unloaded = unloaded + NEW.quantity
            WHERE event_id = NEW.event_id 
                AND event_date = NEW.event_date 
                AND day_part = NEW.day_part 
                AND item_id = NEW.item_id;
        END IF;
    --
    WHEN 'UPDATE' THEN
        -- get item type
        SELECT item_type INTO ity FROM company.item WHERE item_id = NEW.item_id; -- item include company
        -- for kit item
        IF ity = 'K' THEN
            FOR ipr, qty IN SELECT part_id, quantity 
                            FROM company.item_part 
                            WHERE item_id = NEW.item_id 
                LOOP
                    -- for stock inventory
                    UPDATE company.stock_inventory 
                    SET unloaded = unloaded - OLD.quantity * qty + NEW.quantity * qty 
                    WHERE event_id = NEW.event_id 
                        AND item_id = ipr; -- only record alredy present are updated
                    -- for stock unload
                    -- initialize values on not present/change day/change daypart
                    IF NOT EXISTS(  SELECT stock_unload_id 
                                    FROM company.stock_unload 
                                    WHERE event_id = NEW.event_id 
                                    AND event_date = NEW.event_date 
                                    AND day_part = NEW.day_part 
                                    AND item_id = ipr) THEN
                        INSERT INTO company.stock_unload (company_id, event_id, event_date, day_part, item_id) 
                        VALUES (NEW.company_id, NEW.event_id, NEW.event_date, NEW.day_part, ipr);
                    END IF;
                    -- update unload
                    UPDATE company.stock_unload
                    SET unloaded = unloaded - OLD.quantity * qty + NEW.quantity * qty
                    WHERE event_id = NEW.event_id 
                        AND event_date = NEW.event_date 
                        AND day_part = NEW.day_part 
                        AND item_id = ipr;
                END LOOP; 
        -- normal items, menu are not present in order_line_department
        ELSE
            -- for stock inventory
            UPDATE company.stock_inventory 
            SET unloaded = unloaded - OLD.quantity + NEW.quantity
            WHERE event_id = NEW.event_id 
                AND item_id = NEW.item_id; -- only record alredy present are updated
            -- for stock unload
            -- initialize values on not present/change day/change daypart
            IF NOT EXISTS(  SELECT stock_unload_id 
                            FROM company.stock_unload 
                            WHERE event_id = NEW.event_id 
                            AND event_date = NEW.event_date 
                            AND day_part = NEW.day_part 
                            AND item_id = NEW.item_id) THEN
                INSERT INTO company.stock_unload (company_id, event_id, event_date, day_part, item_id) 
                VALUES (NEW.company_id, NEW.event_id, NEW.event_date, NEW.day_part, NEW.item_id);
            END IF;
            -- update unload
            UPDATE company.stock_unload
            SET unloaded = unloaded - OLD.quantity + NEW.quantity
            WHERE event_id = NEW.event_id 
                AND event_date = NEW.event_date 
                AND day_part = NEW.day_part 
                AND item_id = NEW.item_id;
        END IF;
    --
    WHEN 'DELETE' THEN
        -- get item type
        SELECT item_type INTO ity FROM company.item WHERE item_id = OLD.item_id;
        IF ity = 'K' THEN -- kit items
            FOR ipr, qty IN SELECT part_id, quantity 
                            FROM company.item_part 
                            WHERE item_id = OLD.item_id 
                LOOP
                    -- for stock inventory
                    UPDATE company.stock_inventory 
                    SET unloaded = unloaded - OLD.quantity * qty
                    WHERE event_id = OLD.event_id 
                        AND item_id = ipr; -- only record alredy present are updated
                    -- for stock unload
                    -- initialize values on not present/change day/change daypart (on delete can happend if item unload control was modified)
                    IF NOT EXISTS(  SELECT stock_unload_id 
                                    FROM company.stock_unload 
                                    WHERE event_id = OLD.event_id 
                                        AND event_date = OLD.event_date 
                                        AND day_part = OLD.day_part 
                                        AND item_id = ipr) THEN
                        INSERT INTO company.stock_unload (company_id, event_id, event_date, day_part, item_id) 
                        VALUES (OLD.company_id, OLD.event_id, OLD.event_date, OLD.day_part, ipr);
                    END IF;
                    -- update unload
                    UPDATE company.stock_unload
                    SET unloaded = unloaded - OLD.quantity * qty
                    WHERE event_id = OLD.event_id 
                        AND event_date = OLD.event_date 
                        AND day_part = OLD.day_part 
                        AND item_id = ipr;
                END LOOP;
        ELSE -- normal items
            -- for stock inventory
            UPDATE company.stock_inventory 
            SET unloaded = unloaded - OLD.quantity
            WHERE event_id = OLD.event_id 
                AND item_id = OLD.item_id; -- only record alredy present are updated
            -- stock unload
            -- initialize values on not present/change day/change daypart (on delete can happend if item unload control was modified)
            IF NOT EXISTS(  SELECT stock_unload_id 
                            FROM company.stock_unload 
                            WHERE event_id = OLD.event_id 
                                AND event_date = OLD.event_date 
                                AND day_part = OLD.day_part 
                                AND item_id = OLD.item_id) THEN
                INSERT INTO company.stock_unload (company_id, event_id, event_date, day_part, item_id) 
                VALUES (OLD.company_id, OLD.event_id, OLD.event_date, OLD.day_part, OLD.item_id);
            END IF;
            -- update unload
            UPDATE company.stock_unload
            SET unloaded = unloaded - OLD.quantity
            WHERE event_id = OLD.event_id 
                AND event_date = OLD.event_date 
                AND day_part = OLD.day_part 
                AND item_id = OLD.item_id;
        END IF;
    --
    END CASE;
    RETURN NULL;
END;
$$ 
LANGUAGE plpgsql;
COMMENT ON FUNCTION order_line_to_unloaded() IS
    'Function for order line to unloads';
ALTER FUNCTION order_line_to_unloaded() 
    OWNER TO {pyAppPgOwnerRole};


-- order line department table (required for menu item that are present only in customer order but exploded in department order)
CREATE TABLE order_line_department (
    created_at               timestamptz(3) NOT NULL,
	created_by               text NOT NULL,
    updated_at               timestamptz(3) NOT NULL,
	updated_by               text NOT NULL,
    object_version           integer NOT NULL,
    --
    company_id               integer NOT NULL,
    --
    order_line_department_id integer GENERATED BY DEFAULT AS IDENTITY,
    order_header_id          integer NOT NULL,
    event_id                 integer NOT NULL, -- for inventory trigger 
    event_date               date NOT NULL, -- for unload trigger
    day_part                 char NOT NULL, -- for unload trigger 
    department_id            integer NOT NULL,
    item_id                  integer NOT NULL,
    variants                 text,
    quantity                 numeric(12, 2) NOT NULL DEFAULT 1,
    external_code            integer,
    --
    CONSTRAINT order_line_department_pk 
        PRIMARY KEY (order_line_department_id) 
        USING INDEX TABLESPACE {pyAppPgIndexesTS},
    CONSTRAINT order_line_department_header_fk 
        FOREIGN KEY (order_header_id) 
        REFERENCES order_header (order_header_id)
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
    CONSTRAINT order_line_department_company_fk 
        FOREIGN KEY (company_id)
        REFERENCES system.company (company_id) 
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
    CONSTRAINT order_line_department_event_fk 
        FOREIGN KEY (event_id) 
        REFERENCES event (event_id)
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
    CONSTRAINT order_line_department_day_part_check 
        CHECK (day_part IN ('L', 'D')), -- (L)unch / (D)inner
    CONSTRAINT order_line_department_department_fk 
        FOREIGN KEY (department_id) 
        REFERENCES department (department_id)
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT order_line_department_item_fk 
        FOREIGN KEY (item_id) 
        REFERENCES item (item_id)
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION

) TABLESPACE {pyAppPgTablesTS};
COMMENT ON TABLE order_line_department IS 
    'Order line departments table';
ALTER TABLE order_line_department 
    OWNER TO {pyAppPgOwnerRole};

CREATE INDEX order_line_department_index 
    ON company.order_line_department (company_id, order_line_department_id,
         order_header_id, event_id, event_date, day_part, department_id);

CREATE TRIGGER t99_update_company_user_date 
    BEFORE INSERT OR UPDATE ON order_line_department 
    FOR EACH ROW EXECUTE PROCEDURE system.update_company_user_date();

CREATE TRIGGER t10_order_line_to_unloaded 
    AFTER INSERT OR UPDATE OR DELETE ON order_line_department 
    FOR EACH ROW EXECUTE PROCEDURE order_line_to_unloaded();
