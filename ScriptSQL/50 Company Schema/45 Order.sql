-- **************************
-- ** APPLICATION DATABASE **
-- **************************
--

-- Paolo De Stefani 01.2025
--

-- This script MUST be executed by postgres user or a postgres like user
-- Connected to a database ("postgres" database is OK)

---------------------------------
-- APPLICATION DB ARCHITECTURE --
---------------------------------

-- * one database {pyAppPgDataBase}
-- * one role that own the database {pyAppPgOwnerRole} without login privilege
-- * one login role {pyAppPgLoginRole} that inherit {pyAppPgOwnerRole} privileges

-- Every database has 4 schemas:
-- * system     for system objects
-- * common     for common objects that are shared with all companies
-- * company    for objects associated with a company
-- * temp       for temporary tables

-- This set of variables will be be resolved before executing the scripts:
-- {pyAppPgOwnerRole}           = PostgresSQL Role that own all db objects without login privilege
-- {pyAppPgDataBase}            = Postgres database name
-- {pyAppPgLoginRole}           = PostgresSQL Role used for standard login users
-- {pyAppPgLoginPassword}       = Password for pyAppPgLoginRole
-- {pyAppName}                  = Python application name
-- {pyAppDescription}           = Python application description
-- {pyAppVersionMajor}          = Application version major number
-- {pyAppVersionMinor}          = Application version minor number
-- {pyAppVersionPatch}          = Application version patch number
-- {pyAppVersionTag}            = Application version tag
-- {pyAppVersionDescription}    = Application version description
-- {pyAppPgDataBaseTS}          = Database table space (MUST be created before script execution)
-- {pyAppPgTablesTS}            = Tables table space (MUST be created before script execution)
-- {pyAppPgIndexesTS}           = Indexes table space (MUST be created before script execution)


----------------------------
-- COMPANY SCHEMA OBJECTS --
----------------------------

SET search_path = company;


-- document numbers
DROP TABLE IF EXISTS numbering CASCADE;
CREATE TABLE numbering (
    created_at          timestamptz(3) NOT NULL,
	created_by          text NOT NULL,
    updated_at          timestamptz(3) NOT NULL,
	updated_by          text NOT NULL,
    object_version      integer NOT NULL,
    --
    company_id          integer NOT NULL,
    --
    numbering_id        integer GENERATED BY DEFAULT AS IDENTITY,
    event_id            integer NOT NULL,
    event_date          date NULL,
    day_part            CHAR NULL,
    current_value       integer NOT NULL DEFAULT 0,
    --
    CONSTRAINT numbering_pk 
        PRIMARY KEY (numbering_id ) 
        USING INDEX TABLESPACE {pyAppPgIndexesTS},
    CONSTRAINT numbering_company_fk 
        FOREIGN KEY (company_id)
        REFERENCES system.company (company_id) 
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
    CONSTRAINT numbering_event_fk 
        FOREIGN KEY (event_id) 
        REFERENCES event (event_id)
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
    CONSTRAINT numbering_day_part_check 
        CHECK (day_part IN ('L', 'D')) -- (L)unch / (D)inner

) TABLESPACE {pyAppPgTablesTS};
COMMENT ON TABLE numbering IS 
    'This table stores current numbering for order';
ALTER TABLE numbering 
    OWNER TO {pyAppPgOwnerRole};

CREATE INDEX numbering_keys_idx ON numbering (company_id, numbering_id, event_id);

CREATE TRIGGER t99_update_company_user_date 
    BEFORE INSERT OR UPDATE ON numbering  
    FOR EACH ROW EXECUTE PROCEDURE system.update_company_user_date();


-- updating numbering trigger
CREATE FUNCTION update_numbering_table() 
RETURNS trigger AS
$$  
DECLARE 
    num integer;
    lunch_time time;
    dinner_time time;   
BEGIN
    -- update current order number if > of the previous, create a record if not present
    num :=  (
        SELECT current_value
        FROM company.numbering
        WHERE event_id = NEW.event_id
            AND event_date = NEW.stat_order_date
            AND day_part = NEW.stat_order_day_part);  -- event include company
    IF num IS NULL THEN
        INSERT INTO company.numbering (
            company_id,
            event_id,
            event_date,
            day_part,
            current_value) 
        VALUES (
            NEW.company_id,
            NEW.event_id,
            NEW.stat_order_date,
            NEW.stat_order_day_part,
            0);
        num := 0;
    END IF;
    IF NEW.order_number > num THEN
        UPDATE company.numbering 
        SET current_value = NEW.order_number 
        WHERE event_id = NEW.event_id
            AND event_date = NEW.stat_order_date
            AND day_part = NEW.stat_order_day_part; -- event include company
    END IF;
    RETURN NULL;
END
$$ 
LANGUAGE plpgsql;
COMMENT ON FUNCTION update_numbering_table() IS
    'Function for update numbering';
ALTER FUNCTION update_numbering_table() 
    OWNER TO {pyAppPgOwnerRole};



-- trigger for UPDATE order header status and order line department on order header department update
CREATE FUNCTION order_header_department_update() 
RETURNS trigger AS 
$$
DECLARE
    i int;                  -- order line department iterator
BEGIN
    -- order header status will be
    -- (A)quired, (I)in progress, (P)rocessed
    -- if order header department is NOT fullfilled then department lines move ordered quantity
    -- if order header department is fullfilled then department lines move delivered quantity and ordered quantity is set to zero

    -- ORDER LINE DEPARTMENT ordered/delivered quantity
    FOR i IN 
        SELECT order_line_department_id 
        FROM company.order_line_department 
        WHERE order_header_department_id = NEW.order_header_department_id
    LOOP
        IF NEW.fullfillment_date IS NULL THEN
            -- ordered
            UPDATE company.order_line_department
            SET ordered_quantity    = quantity,
                delivered_quantity  = 0
            WHERE order_line_department_id = i;
        ELSE
            -- delivered
            UPDATE company.order_line_department
            SET ordered_quantity    = 0,
                delivered_quantity  = quantity
            WHERE order_line_department_id = i;
        END IF;
    END LOOP;

    -- ORDER HEADER status
	IF (
        SELECT bool_and(CASE WHEN fullfillment_date IS NULL THEN false ELSE true END) 
        FROM company.order_header_department 
        WHERE order_header_id = NEW.order_header_id
        ) THEN
        UPDATE company.order_header 
        SET status = 'P', fullfillment_date = now() 
        WHERE order_header_id = NEW.order_header_id;
	ELSIF ( 
        SELECT bool_or(CASE WHEN fullfillment_date IS NULL THEN false ELSE true END) 
        FROM company.order_header_department 
        WHERE order_header_id = NEW.order_header_id
        ) THEN
		UPDATE company.order_header 
        SET status = 'I', fullfillment_date = Null 
        WHERE order_header_id = NEW.order_header_id;
    ELSE
        UPDATE company.order_header
        SET status = 'A', fullfillment_date = Null 
        WHERE order_header_id = NEW.order_header_id;
	END IF;

    RETURN NULL;
END;
$$ 
LANGUAGE plpgsql;
COMMENT ON FUNCTION order_header_department_update() IS
    'Function for order header department status update department lines and order header status';
ALTER FUNCTION order_header_department_update() 
    OWNER TO {pyAppPgOwnerRole};


-- order header table
CREATE TABLE order_header (
    created_at              timestamptz(3) NOT NULL,
	created_by              text NOT NULL,
    updated_at              timestamptz(3) NOT NULL,
	updated_by              text NOT NULL,
    object_version          integer NOT NULL,
    --
    company_id              integer NOT NULL,
    --
    order_header_id         integer GENERATED BY DEFAULT AS IDENTITY,
    event_id                integer NOT NULL,
    date_time               timestamptz(3) NOT NULL DEFAULT now(),
    order_number            integer NOT NULL,
    order_date              date NOT NULL,
    order_time              time NOT NULL,
    stat_order_date         date NOT NULL,
    stat_order_day_part     CHAR NOT NULL,
	cash_desk               text NOT NULL,
    delivery                char NOT NULL,
    table_num               varchar(10),
    customer_name           varchar(60),
    customer_contact        varchar(128), -- email or other contact info
    covers                  integer,
    total_amount            numeric(12, 2) NOT NULL DEFAULT 0,
    discount                numeric(12, 2) NOT NULL DEFAULT 0,
    cash                    numeric(12, 2) NOT NULL DEFAULT 0,
    change                  numeric(12, 2) NOT NULL DEFAULT 0,
    is_electronic_payment   boolean NOT NULL DEFAULT false,
    is_from_web             boolean NOT NULL DEFAULT false,
    status                  char NOT NULL DEFAULT 'A', -- (A)quired, (I)in progress, (P)rocessed
	fullfillment_date       timestamptz(3) NULL,
    external_code           integer,
    --
    CONSTRAINT order_header_pk 
        PRIMARY KEY (order_header_id) 
        USING INDEX TABLESPACE {pyAppPgIndexesTS},
    CONSTRAINT order_header_company_fk 
        FOREIGN KEY (company_id)
        REFERENCES system.company (company_id) 
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
    CONSTRAINT order_header_delivery_check 
        CHECK (delivery IN ('T', 'A')), -- (T)able or take(A)way
    CONSTRAINT order_header_day_part_check 
        CHECK (stat_order_day_part IN ('L', 'D')), -- (L)unch / (D)inner
	CONSTRAINT order_header_status_check 
        CHECK (status IN ('A', 'I', 'P')), -- (A)quired, (I)in progress, (P)rocessed
    CONSTRAINT order_header_event_fk 
        FOREIGN KEY (event_id) 
        REFERENCES event (event_id)
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
    CONSTRAINT order_header_docnum_unique 
        UNIQUE (event_id, order_number, order_date)

) TABLESPACE {pyAppPgTablesTS};
COMMENT ON TABLE order_header IS 
    'Order headers table';
ALTER TABLE order_header 
    OWNER TO {pyAppPgOwnerRole};

CREATE INDEX order_header_keys_idx ON order_header (company_id, order_header_id, event_id);

CREATE TRIGGER t10_update_numbering 
    AFTER INSERT OR UPDATE ON order_header 
    FOR EACH ROW EXECUTE PROCEDURE update_numbering_table();

CREATE TRIGGER t99_update_company_user_date 
    BEFORE INSERT OR UPDATE ON order_header 
    FOR EACH ROW EXECUTE PROCEDURE system.update_company_user_date();


-- order header department table
CREATE TABLE order_header_department (
    created_at                  timestamptz(3) NOT NULL,
	created_by                  text NOT NULL,
    updated_at                  timestamptz(3) NOT NULL,
	updated_by                  text NOT NULL,
    object_version              integer NOT NULL,
    --
    company_id                  integer NOT NULL,
    --
    order_header_department_id  integer GENERATED BY DEFAULT AS IDENTITY,
    order_header_id             integer NOT NULL,
    department_id               integer NOT NULL,
    note                        text,
    other_departments           text,
    barcode                     varchar(64) NULL,
	fullfillment_date           timestamptz(3) NULL,
    external_code               integer,
    --
    CONSTRAINT order_header_department_pk 
        PRIMARY KEY (order_header_department_id) 
        USING INDEX TABLESPACE {pyAppPgIndexesTS},
    CONSTRAINT order_header_department_company_fk 
        FOREIGN KEY (company_id)
        REFERENCES system.company (company_id) 
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
    CONSTRAINT order_header_department_header_fk 
        FOREIGN KEY (order_header_id) 
        REFERENCES order_header (order_header_id)
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
    CONSTRAINT order_header_department_department_fk 
        FOREIGN KEY (department_id) 
        REFERENCES department (department_id)
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT order_header_department_barcode_unique 
        UNIQUE (company_id, barcode)

) TABLESPACE {pyAppPgTablesTS};
COMMENT ON TABLE order_header_department IS 
    'Order headers department table';
ALTER TABLE order_header_department 
    OWNER TO {pyAppPgOwnerRole};

CREATE INDEX order_header_department_keys_idx 
    ON order_header_department (company_id, order_header_department_id, order_header_id, department_id);

CREATE TRIGGER t10_update_order_header_department
    AFTER UPDATE ON order_header_department 
    FOR EACH ROW EXECUTE PROCEDURE order_header_department_update();

CREATE TRIGGER t99_update_company_user_date 
    BEFORE INSERT OR UPDATE ON order_header_department 
    FOR EACH ROW EXECUTE PROCEDURE system.update_company_user_date();


-- order line table
CREATE TABLE order_line (
    created_at              timestamptz(3) NOT NULL,
	created_by              text NOT NULL,
    updated_at              timestamptz(3) NOT NULL,
	updated_by              text NOT NULL,
    object_version          integer NOT NULL,
    --
    company_id              integer NOT NULL,
    --
    order_line_id           integer GENERATED BY DEFAULT AS IDENTITY,
    order_header_id         integer NOT NULL,
    item_id                 integer NOT NULL,
    variants                text,
    quantity                numeric(12, 2) NOT NULL DEFAULT 1,
    price                   numeric(12, 2) NOT NULL DEFAULT 0,
    amount                  numeric(12, 2) NOT NULL DEFAULT 0,
    external_code           integer,
    --
    CONSTRAINT order_line_pk 
        PRIMARY KEY (order_line_id) 
        USING INDEX TABLESPACE {pyAppPgIndexesTS},
    CONSTRAINT order_line_header_fk 
        FOREIGN KEY (order_header_id) 
        REFERENCES order_header (order_header_id)
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
    CONSTRAINT order_line_company_fk 
        FOREIGN KEY (company_id)
        REFERENCES system.company (company_id) 
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
    CONSTRAINT order_line_item_fk 
        FOREIGN KEY (item_id) 
        REFERENCES item (item_id)
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION

) TABLESPACE {pyAppPgTablesTS};
COMMENT ON TABLE order_line IS 
    'Order line table';
ALTER TABLE order_line 
    OWNER TO {pyAppPgOwnerRole};

CREATE INDEX order_line_keys_idx 
    ON order_line (company_id, order_line_id, order_header_id, item_id);

CREATE TRIGGER t99_update_company_user_date 
    BEFORE INSERT OR UPDATE ON order_line 
    FOR EACH ROW EXECUTE PROCEDURE system.update_company_user_date();


-- trigger for update inventory
CREATE FUNCTION order_line_to_inventory() 
    RETURNS trigger AS 
$$
DECLARE
    item        int;            -- item
    itempart    int;            -- item part
    partqty     numeric(12, 2); -- part quantity
BEGIN
    --
    -- For inventory we consider only record already present, user must initialize them setting a load quantity
    --

    --
    CASE TG_OP
    --
    WHEN 'INSERT' THEN
        -- with this query i can consider normal item and kit simultaneously
        -- normal items are part items with part quantity = 1
        FOR item, itempart, partqty IN 
            SELECT 
                i.item, 
                i.part,
                i.qty
            FROM (
                -- normal item
                SELECT 
                    item_id  AS item,
                    item_id  AS part,
                    1        AS qty
                FROM company.item
                WHERE item_type = 'I'
                UNION
                -- kit
                SELECT 
                    item_id  AS item,
                    part_id  AS part,
                    quantity AS qty 
                FROM company.item_part 
                WHERE item_type = 'K'
                ) i
            WHERE i.item = NEW.item_id 
        LOOP
            -- update items inventory
            UPDATE company.inventory 
            SET unloaded = unloaded + NEW.delivered_quantity * partqty,
                ordered  = ordered + NEW.ordered_quantity * partqty
            WHERE event_id = NEW.event_id 
                AND item_id = itempart;
        END LOOP;

    WHEN 'UPDATE' THEN
        -- with this query i can consider normal item and kit simultaneously
        -- normal items are part items with part quantity = 1
        FOR item, itempart, partqty IN 
            SELECT 
                i.item, 
                i.part,
                i.qty
            FROM (
                -- normal item
                SELECT 
                    item_id  AS item,
                    item_id  AS part,
                    1        AS qty
                FROM company.item
                WHERE item_type = 'I'
                UNION
                -- kit
                SELECT 
                    item_id  AS item,
                    part_id  AS part,
                    quantity AS qty 
                FROM company.item_part 
                WHERE item_type = 'K'
                ) i
            WHERE i.item = NEW.item_id 
        LOOP
            -- items inventory
            UPDATE company.inventory 
            SET unloaded = unloaded - OLD.delivered_quantity * partqty + NEW.delivered_quantity * partqty, 
                ordered  = ordered - OLD.ordered_quantity * partqty + NEW.ordered_quantity * partqty
            WHERE event_id = NEW.event_id 
                AND item_id = itempart;
        END LOOP; 

    WHEN 'DELETE' THEN
        -- with this query i can consider normal item and kit simultaneously
        -- normal items are part items with part quantity = 1
        FOR item, itempart, partqty IN 
            SELECT 
                i.item, 
                i.part,
                i.qty
            FROM (
                -- normal item
                SELECT 
                    item_id  AS item,
                    item_id  AS part,
                    1        AS qty
                FROM company.item
                WHERE item_type = 'I'
                UNION
                -- kit
                SELECT 
                    item_id  AS item,
                    part_id  AS part,
                    quantity AS qty 
                FROM company.item_part 
                WHERE item_type = 'K'
                ) i
            WHERE i.item = OLD.item_id 
            LOOP
                -- for items inventory
                -- initialize values on delete can happend if item inventory/delivered control was modified
                IF NOT EXISTS(  SELECT inventory_id 
                                FROM company.inventory 
                                WHERE event_id = OLD.event_id  
                                    AND item_id = itempart) THEN
                    IF (SELECT has_inventory_control FROM company.item WHERE item_id = itempart) THEN
                        INSERT INTO company.inventory (company_id, event_id, item_id) 
                        VALUES (OLD.company_id, OLD.event_id, itempart);
                    END IF;
                END IF;
                -- update inventory
                UPDATE company.inventory 
                SET unloaded = unloaded - OLD.delivered_quantity * partqty,
                    ordered  = ordered - OLD.ordered_quantity * partqty
                WHERE event_id = OLD.event_id 
                    AND item_id = itempart;
            END LOOP;

    END CASE;
    RETURN NULL;
END;
$$ 
LANGUAGE plpgsql;
COMMENT ON FUNCTION order_line_to_inventory() IS
    'Function for update inventory from order line department';
ALTER FUNCTION order_line_to_inventory() 
    OWNER TO {pyAppPgOwnerRole};


-- trigger for update ordered delivered
CREATE FUNCTION order_line_to_ordered_delivered() 
    RETURNS trigger AS 
$$
BEGIN
    --
    -- For ordered/delivered we consider only saled items, no kit
    -- and initialize a record if not present only for suitable items
    --

    --
    CASE TG_OP
    --
    WHEN 'INSERT' THEN
        IF NOT EXISTS(  SELECT ordered_delivered_id 
                        FROM company.ordered_delivered 
                        WHERE   event_id    = NEW.event_id 
                            AND event_date  = NEW.event_date 
                            AND day_part    = NEW.day_part 
                            AND item_id     = NEW.item_id) THEN
            IF (SELECT has_delivered_control FROM company.item WHERE item_id = NEW.item_id) THEN
                INSERT INTO company.ordered_delivered (company_id, event_id, event_date, day_part, item_id) 
                VALUES (NEW.company_id, NEW.event_id, NEW.event_date, NEW.day_part, NEW.item_id);
            END IF;
        END IF;
        -- update ordered delivered
        UPDATE company.ordered_delivered
        SET ordered   = ordered + NEW.ordered_quantity,
            delivered = delivered + NEW.delivered_quantity
        WHERE event_id = NEW.event_id 
            AND event_date = NEW.event_date 
            AND day_part = NEW.day_part 
            AND item_id = NEW.item_id;

    WHEN 'UPDATE' THEN
        IF NOT EXISTS(  SELECT ordered_delivered_id 
                    FROM company.ordered_delivered 
                    WHERE   event_id    = NEW.event_id 
                        AND event_date  = NEW.event_date 
                        AND day_part    = NEW.day_part 
                        AND item_id     = NEW.item_id) THEN
            IF (SELECT has_delivered_control FROM company.item WHERE item_id = NEW.item_id) THEN
                INSERT INTO company.ordered_delivered (company_id, event_id, event_date, day_part, item_id) 
                VALUES (NEW.company_id, NEW.event_id, NEW.event_date, NEW.day_part, NEW.item_id);
            END IF;
        END IF;
        -- update ordered delivered
        UPDATE company.ordered_delivered
        SET ordered = ordered - OLD.ordered_quantity + NEW.ordered_quantity,
            delivered = delivered - OLD.delivered_quantity + NEW.delivered_quantity
        WHERE event_id = NEW.event_id 
            AND event_date = NEW.event_date 
            AND day_part = NEW.day_part 
            AND item_id = NEW.item_id;

    WHEN 'DELETE' THEN
        IF NOT EXISTS(  SELECT ordered_delivered_id 
                        FROM company.ordered_delivered 
                        WHERE event_id = OLD.event_id 
                            AND event_date = OLD.event_date 
                            AND day_part = OLD.day_part 
                            AND item_id = OLD.item_id) THEN
            IF (SELECT has_delivered_control FROM company.item WHERE item_id = OLD.item_id) THEN
                INSERT INTO company.ordered_delivered (company_id, event_id, event_date, day_part, item_id) 
                VALUES (OLD.company_id, OLD.event_id, OLD.event_date, OLD.day_part, OLD.item_id);
            END IF;
        END IF;
        -- update unload
        UPDATE company.ordered_delivered
        SET ordered = ordered - OLD.ordered_quantity,
            delivered = delivered - OLD.delivered_quantity
        WHERE event_id = OLD.event_id 
            AND event_date = OLD.event_date 
            AND day_part = OLD.day_part 
            AND item_id = OLD.item_id;

    END CASE;
    RETURN NULL;
END;
$$ 
LANGUAGE plpgsql;
COMMENT ON FUNCTION order_line_to_ordered_delivered() IS
    'Function for update ordered/delivered from order line department';
ALTER FUNCTION order_line_to_ordered_delivered() 
    OWNER TO {pyAppPgOwnerRole};


-- order line department table (required for menu item that are present only in customer order but exploded in department order)
CREATE TABLE order_line_department (
    created_at                  timestamptz(3) NOT NULL,
	created_by                  text NOT NULL,
    updated_at                  timestamptz(3) NOT NULL,
	updated_by                  text NOT NULL,
    object_version              integer NOT NULL,
    --
    company_id                  integer NOT NULL,
    --
    order_line_department_id    integer GENERATED BY DEFAULT AS IDENTITY,
    order_header_department_id  integer NOT NULL,
    event_id                    integer NOT NULL,  -- for inventory trigger 
    event_date                  date NOT NULL,     -- for unload trigger
    day_part                    char NOT NULL,     -- for unload trigger 
    item_id                     integer NOT NULL,
    variants                    text,
    quantity                    numeric(12, 2) NOT NULL DEFAULT 0,
    ordered_quantity            numeric(12, 2) NOT NULL DEFAULT 0, -- for stock_inventory.ordered_quantity
    delivered_quantity          numeric(12, 2) NOT NULL DEFAULT 0, -- for stock_inventory.unload and stock unload.unload 
    external_code               integer,
    --
    CONSTRAINT order_line_department_pk 
        PRIMARY KEY (order_line_department_id) 
        USING INDEX TABLESPACE {pyAppPgIndexesTS},
    CONSTRAINT order_line_department_header_department_fk 
        FOREIGN KEY (order_header_department_id) 
        REFERENCES order_header_department (order_header_department_id)
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
    CONSTRAINT order_line_department_company_fk 
        FOREIGN KEY (company_id)
        REFERENCES system.company (company_id) 
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
    CONSTRAINT order_line_department_event_fk 
        FOREIGN KEY (event_id) 
        REFERENCES event (event_id)
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
    CONSTRAINT order_line_department_day_part_check 
        CHECK (day_part IN ('L', 'D')), -- (L)unch / (D)inner
    CONSTRAINT order_line_department_item_fk 
        FOREIGN KEY (item_id) 
        REFERENCES item (item_id)
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION

) TABLESPACE {pyAppPgTablesTS};
COMMENT ON TABLE order_line_department IS 
    'Order line departments table';
ALTER TABLE order_line_department 
    OWNER TO {pyAppPgOwnerRole};

CREATE INDEX order_line_department_keys_idx 
    ON order_line_department (company_id, order_line_department_id, order_header_department_id, event_id);

CREATE TRIGGER t99_update_company_user_date 
    BEFORE INSERT OR UPDATE ON order_line_department 
    FOR EACH ROW EXECUTE PROCEDURE system.update_company_user_date();

CREATE TRIGGER t10_order_line_to_inventory
    AFTER INSERT OR UPDATE OR DELETE ON order_line_department 
    FOR EACH ROW EXECUTE PROCEDURE order_line_to_inventory();

CREATE TRIGGER t20_order_line_to_ordered_delivered
    AFTER INSERT OR UPDATE OR DELETE ON order_line_department 
    FOR EACH ROW EXECUTE PROCEDURE order_line_to_ordered_delivered();
