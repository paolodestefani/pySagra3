--
-- **************************
-- ** APPLICATION DATABASE **
-- **************************
--

-- Paolo De Stefani 01.2025

-- This script MUST be executed by postgres user or a postgres like user
-- Connected to a database ("postgres" database is OK)

---------------------------------
-- APPLICATION DB ARCHITECTURE --
---------------------------------

-- * one database {pyAppPgDataBase}
-- * one role that own the database {pyAppPgOwnerRole} without login privilege
-- * one login role {pyAppPgLoginRole} that inherit {pyAppPgOwnerRole} privileges

-- Every database has 4 schemas:
-- * system     for system objects
-- * common     for common objects that are shared with all companies
-- * company    for objects associated with a company
-- * temp       for temporary tables

-- This set of variables will be be resolved before executing the scripts:
-- {pyAppPgOwnerRole}           = PostgresSQL Role that own all db objects without login privilege
-- {pyAppPgDataBase}            = Postgres database name
-- {pyAppPgLoginRole}           = PostgresSQL Role used for standard login users
-- {pyAppPgLoginPassword}       = Password for pyAppPgLoginRole
-- {pyAppName}                  = Python application name
-- {pyAppDescription}           = Python application description
-- {pyAppVersionMajor}          = Application version major number
-- {pyAppVersionMinor}          = Application version minor number
-- {pyAppVersionPatch}          = Application version patch number
-- {pyAppVersionTag}            = Application version tag
-- {pyAppVersionDescription}    = Application version description
-- {pyAppPgDataBaseTS}          = Database table space (MUST be created before script execution)
-- {pyAppPgTablesTS}            = Tables table space (MUST be created before script execution)
-- {pyAppPgIndexesTS}           = Indexes table space (MUST be created before script execution)

-- for string quoting put a * e.g. {pyAppPgOwnerRole*} -> 'pa_owner_role'


----------------------------
-- COMPANY SCHEMA OBJECTS --
----------------------------

SET search_path = company;


-- stock_summary compute balance trigger
CREATE FUNCTION stock_inventory_balance() 
RETURNS trigger AS 
$$
BEGIN
    UPDATE company.stock_inventory
    SET balance = loaded - unloaded
    WHERE stock_inventory_id = NEW.stock_inventory_id;
    RETURN NULL;
END;
$$ 
LANGUAGE plpgsql;
COMMENT ON FUNCTION stock_inventory_balance() IS
    'Function for calculate the stock balance';
ALTER FUNCTION stock_inventory_balance() 
    OWNER TO {pyAppPgOwnerRole};


-- stocks inventory table
-- record are manually inserted, this trigger only update records already present in table
CREATE TABLE stock_inventory (
    created_at          timestamptz(3) NOT NULL,
	created_by          text NOT NULL,
    updated_at          timestamptz(3) NOT NULL,
	updated_by          text NOT NULL,
    object_version      integer NOT NULL,
    --
    company_id          integer NOT NULL,
    --
    stock_inventory_id  integer GENERATED BY DEFAULT AS IDENTITY,
    event_id            integer NOT NULL,
    item_id             integer NOT NULL,
    loaded              numeric(12, 2) NOT NULL DEFAULT 0,
    unloaded            numeric(12, 2) NOT NULL DEFAULT 0,
    balance             numeric(12, 2) NOT NULL DEFAULT 0,
    external_code       integer,
    --
    CONSTRAINT stock_inventory_pk 
        PRIMARY KEY (stock_inventory_id) 
        USING INDEX TABLESPACE {pyAppPgIndexesTS},
    CONSTRAINT stock_inventory_company_fk 
        FOREIGN KEY (company_id)
        REFERENCES system.company (company_id) 
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
    CONSTRAINT stock_inventory_event_fk 
        FOREIGN KEY (event_id) 
        REFERENCES event (event_id)
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT stock_inventory_item_fk 
        FOREIGN KEY (item_id) 
        REFERENCES item (item_id)
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT stock_inventory_event_item_unique 
        UNIQUE (company_id, event_id, item_id)

) TABLESPACE {pyAppPgTablesTS};
COMMENT ON TABLE stock_inventory IS 
    'Stocks summary table';
ALTER TABLE stock_inventory 
    OWNER TO {pyAppPgOwnerRole};

CREATE TRIGGER t10_stock_inventory_balance 
    AFTER INSERT OR UPDATE OF loaded, unloaded ON stock_inventory 
    FOR EACH ROW EXECUTE PROCEDURE stock_inventory_balance();

CREATE TRIGGER t99_update_company_user_date 
    BEFORE INSERT OR UPDATE ON stock_inventory  
    FOR EACH ROW EXECUTE PROCEDURE system.update_company_user_date();


-- stock unload report table
CREATE TABLE stock_unload (
    company_id          integer NOT NULL,
    --
    stock_unload_id     integer GENERATED BY DEFAULT AS IDENTITY,
    event_id            integer NOT NULL,
    event_date          date NULL,
    day_part            char NULL,
    item_id             integer NOT NULL,
    unloaded            numeric(12, 2) DEFAULT 0,
    --
    CONSTRAINT stock_unload_pk 
        PRIMARY KEY (stock_unload_id) 
        USING INDEX TABLESPACE {pyAppPgIndexesTS},
    CONSTRAINT stock_unload_company_fk 
        FOREIGN KEY (company_id)
        REFERENCES system.company (company_id) 
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
    CONSTRAINT stock_unload_event_fk 
        FOREIGN KEY (event_id) 
        REFERENCES event (event_id)
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
    CONSTRAINT stock_unload_day_part_check 
        CHECK (day_part IN ('L', 'D')),
    CONSTRAINT stock_unload_item_fk 
        FOREIGN KEY (item_id) 
        REFERENCES item (item_id)
        MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
    CONSTRAINT stock_unload_record_unique 
        UNIQUE (company_id, event_id, event_date, day_part, item_id)

) TABLESPACE {pyAppPgTablesTS};
COMMENT ON TABLE stock_unload IS 
    'Item  for stock unload report';
ALTER TABLE stock_unload 
    OWNER TO {pyAppPgOwnerRole};

